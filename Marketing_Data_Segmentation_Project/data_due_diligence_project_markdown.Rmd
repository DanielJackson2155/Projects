---
title: "Data Due Diligence Project"
author: "Daniel Jackson"
date: "`r Sys.Date()`"
output: word_document
---

# Table of Contents
Introduction. 
Rmarkdown Code.  
Summary of Data.  
Tableau Visualizations.  

# Introduction
In this project, we will be looking at a data set that contains a sample of 5,000 customers of a telecommunications company. We will be acting as an incoming marketing analytics manager for the company. Our goal is to conduct a comprehensive assessment of the customer base. Within the Rmarkdown portion of this project, we will be using RStudio to read in, clean, and tidy the data. Throughout the cleansing of the data, we will create a subset of ten variables that we are interested in for further analysis. These variables will be composed of both qualitative and quantitative. They may also be transformed or they may be a combination of multiple variables. We will go into detail of each of the ten variables that we choose and provide a detailed and clear justification of the feature engineering that we conduct. We will also identify the meaning and the type of each variable chosen.
After we create our subset of ten variables, we will then be using Tableau to provide several single variable plots of our data. We will also perform five two-column visuals to see if there are any relationships between the variables that we chose.
The goal of this project is to provide a cleaned up subset of our original data and then use data visualization tactics to see if there are any relationships between the variables that we choose.
The layout of this project will be:
- Rmarkdown code showing how we read in and manipulated data
- Summary on feature engineering
- Visualizations on chosen subset

# Rmarkdown Code
## Libraries Used
``` {r libraries, echo = TRUE, results = 'hide', message = FALSE}
library(dplyr)
library(tidyr)
library(caret)
library(DescTools)
library(stringr)
library(openxlsx)
```

## Read in Data
```{r setup}
# Read in data
cust_df = read.csv("customer_data.csv")

# Check dimension of data frame
dim(cust_df)
# 5000 observations
# 60 columns
```

## Clean Data
```{r clean up}
# Make all variable names lower case
colnames(cust_df) = tolower(colnames(cust_df))

# Check how many columns have NAs
colSums(is.na(cust_df))

# Column x has 5000 missing NA values. Let's remove that column.
cust_df = cust_df[, -which(names(cust_df) == "x")]
```
# Variables Chosen
## Number of Pets
```{r numberpets}
# We see that numberpets has 6 NAs, numbercats has 7, numberdogs has 8, and
# numberbirds has 34. 
# Let us assume that an NA value in these columns equals zero.
cust_df = cust_df %>%
  mutate(numberpets = ifelse(is.na(numberpets), 0, numberpets),
         numbercats = ifelse(is.na(numbercats), 0, numbercats),
         numberdogs = ifelse(is.na(numberdogs), 0, numberdogs),
         numberbirds = ifelse(is.na(numberbirds), 0, numberbirds))
# We want to focus on just total number of pets in this analysis. So let us make numberpets equal to the sum of numbercats + numberdogs + numberbirds
cust_df$numberpets = (cust_df$numbercats + cust_df$numberdogs + cust_df$numberbirds)
# Now we can remove the numbercats, numberdogs, and numberbirds columns
cust_df = cust_df[, -which(names(cust_df) == "numbercats")]
cust_df = cust_df[, -which(names(cust_df) == "numberdogs")]
cust_df = cust_df[, -which(names(cust_df) == "numberbirds")]
```

## Household
```{r household}
# We also see that household size has 8 NA values.
# Let us find average values of household size based on if customers are married or not.
cust_df %>%
  group_by(maritalstatus) %>%
  summarize(mean_household_size = mean(na.omit(householdsize)))
# We see that the average household size of customers that are married is 3.11 and the average household size of customers that are unmarried is 1.36.
# With this information, let us fill the NA values of household size using these average values.
married_size = 3
unmarried_size = 1
cust_df = cust_df %>%
  mutate(householdsize = if_else(is.na(householdsize), 
              if_else(maritalstatus == "Married", married_size, unmarried_size),
              householdsize))
```

## Homeowner
```{r homeowner}
# We see that homeowner has 13 NA values. The homeowner is a binary column that says either 1 for homeowner or 0 for non-homeowner. Since this is a binary column, let us replace the NA values with the mode for the column.
cust_df = cust_df %>%
  mutate(homeowner = ifelse(is.na(homeowner), Mode(homeowner, na.rm = TRUE),
                            homeowner))
Mode(cust_df$homeowner)
```

## Job Category
```{r jobcategory}
# Looking at the jobcategory variable, we see a few empty strings.
# Check unique values
unique(cust_df$jobcategory)
# We see that there is an empty string in there. Let us make that empty string a NA value
cust_df = cust_df %>%
  mutate(jobcategory = ifelse(jobcategory == "", NA, jobcategory))

# Now we see that there is 15 NA values for jobcategory.
# Let us look at highest count of jobcategory values for those that are in the union and those that are not in the union to help impute values for NA values in jobcategory
cust_df %>%
  group_by(unionmember, jobcategory) %>%
  summarize(count = n(), .groups = "drop")

# For non-union members, sales has highest count in the jobcategory column.
# For union members, professional has highest count. 
# Let us impute those for the missing NA values in jobcategory column.
cust_df = cust_df %>%
  mutate(jobcategory = if_else(is.na(jobcategory) & unionmember == "Yes", 
                               "Professional",
        if_else(is.na(jobcategory) & unionmember == "No","Sales",jobcategory)))
```

## Region
```{r region}
# Let us change the region column from 1, 2, 3, 4, 5 to the respective region names
unique(cust_df$region)

cust_df = cust_df %>%
  mutate(region = ifelse(region == 1, "northeast", 
                  ifelse(region == 2, "midwest", 
                  ifelse(region == 3, "west", 
                  ifelse(region == 4, "southwest", 
                  ifelse(region == 5, "southeast", region))))))
# Check to see names were changed
unique(cust_df$region)
```

## Household Income
```{r hhincome}
# Let us look at the hhincome column. Let us first look at the distribution of the variable and see if a transformation helps the distribution.
class(cust_df$hhincome)
# This is a character vector. We need to remove all non-numeric characters in 
cust_df = cust_df %>%
  mutate(hhincome = as.numeric(str_replace_all(hhincome, "[^0-9.]", "")))

# Check hhincome class again
class(cust_df$hhincome)

# It is now numeric. Let us look at distribution:
hist(cust_df$hhincome,
     xlab = "Household Income in USD Thousands",
     ylab = "Frequency",
     main = "Distribution of Household Income")
# Try log transformation to see how that affects distribution.
# Before we do that, let us see what the min/max value is:
min(cust_df$hhincome)
# Min is 9000
max(cust_df$hhincome)
# Max is 1073000
hist(log(cust_df$hhincome),
     xlab = "Household Income in USD Thousands",
     ylab = "Frequency",
     main = "Distribution of log(Household Income)")
# This made distribution more normal. Let us add a new column and call it log_hh_inc
cust_df = cust_df %>%
  mutate(log_hh_income = log(hhincome))

# Let us look at boxplot to see if we have any outliers
boxplot(cust_df$log_hh_income,
        xlab = "Log Household Income",
        ylab = "Frequency",
        main = "Distribution of Log Household Income")

# We see some outliers. Let us remove them
q = quantile(cust_df$log_hh_income, c(0.25, 0.75))
iqr = q[2] - q[1]

# Set the range for outliers
low_q = q[1] - 1.5 * iqr
upper_q = q[2] + 1.5 * iqr

# Remove outliers from the dataframe
cust_df = cust_df[cust_df$log_hh_income >= low_q 
                  & cust_df$log_hh_income <= upper_q, ]

# Let us look at box plot again
boxplot(cust_df$log_hh_income,
        xlab = "Log Household Income",
        ylab = "Frequency",
        main = "Distribution of Log Household Income")

# We removed those outliers
```

## Total Value Over Tenure
```{r total}
# Let us look at the total value of each customer over their tenure by adding equipmentovertenure, voiceovertenure, and dataovertenure variable together.
# Let us first look at the class of each variable
class(cust_df$equipmentovertenure)
# Character
class(cust_df$voiceovertenure)
# Character
class(cust_df$dataovertenure)
# Character

# Now we need to remove all non-numeric characters
cust_df = cust_df %>%
  mutate(equipmentovertenure = as.numeric(str_replace_all(equipmentovertenure, "[^0-9.]", "")),
  voiceovertenure = as.numeric(str_replace_all(voiceovertenure, "[^0-9.]", "")),
  dataovertenure = as.numeric(str_replace_all(dataovertenure, "[^0-9.]", "")))

# Check for NA values in each column
colSums(is.na(cust_df[, c("equipmentovertenure", "voiceovertenure", "dataovertenure")]))
# If there is a NA value in those columns, it means that the customer does not use those services, therefore we can change all of those NA values to 0 in each column
cust_df = cust_df %>%
  mutate(equipmentovertenure = ifelse(is.na(equipmentovertenure), 0, equipmentovertenure),
         voiceovertenure = ifelse(is.na(voiceovertenure), 0, voiceovertenure),
         dataovertenure = ifelse(is.na(dataovertenure), 0, dataovertenure))

# Check for NA values
colSums(is.na(cust_df[, c("equipmentovertenure", "voiceovertenure", "dataovertenure")]))
# No more NA values
# Confirm each class is numeric
class(cust_df$equipmentovertenure)
class(cust_df$voiceovertenure)
class(cust_df$dataovertenure)
# All variables are numeric

# Now we can create new variable called total_value which will represent total spent over tenure for each customer
cust_df = cust_df %>%
  mutate(total_value = equipmentovertenure + voiceovertenure + dataovertenure)

# Let us look at distribution of total_value
hist(cust_df$total_value,
     xlab = "Total Value",
     ylab = "Frequency",
     main = "Distribution of Total Value")

# We see that there are three customers that have 0 value over their time as a customer.
head(table(cust_df$total_value))

# We see that there are three customers that have 0 total value. Let us drop those observations.
cust_df = cust_df[cust_df$total_value != 0, ]

# Now let us see if a log transformation helps the right skewedness of the total value distribution
hist(log(cust_df$total_value),
     xlab = "log(Total Value)",
     ylab = "Frequency",
     main = "Distribution of log(Total Value) in USD")
# The log transformation makes the distribution slightly left skewed. However, the log transformed distribution is much less skewed than the non-transformed distribution.

# Let us create a new variable called log_tot_value
cust_df = cust_df %>%
  mutate(log_tot_value = log(total_value))

# Let us look at log transformed box plot
boxplot(cust_df$log_tot_value,
     xlab = "Log Total Value",
     ylab = "Frequency",
     main = "Distribution of Log Total Value")
# We see a lot of outliers.

# Let us remove those outliers by calculating the interquartile range of our distribution and remove the points out side of that range
# Calculate the interquartile range
q = quantile(cust_df$log_tot_value, c(0.25, 0.75))
iqr = q[2] - q[1]

# Set the range for outliers
low_q = q[1] - 1.5 * iqr
upper_q = q[2] + 1.5 * iqr

# Remove outliers from the dataframe
cust_df = cust_df[cust_df$log_tot_value >= low_q 
                  & cust_df$log_tot_value <= upper_q, ]

# Look at box plot again
boxplot(cust_df$log_tot_value,
     xlab = "Log Total Value",
     ylab = "Frequency",
     main = "Distribution of Log Total Value")
# This removed the outliers
```

## Total Debt
```{r total debt}
# Let us add creditdebt and otherdebt together and create total_debt column.
class(cust_df$creditdebt)
# numeric
class(cust_df$otherdebt)
# numeric
# From our data dictionary, we know that each debt is expressed in $100,000. Let us convert those debt numbers to represent debt in $100,000 and then add them together.
cust_df = cust_df %>%
  mutate(creditdebt = (creditdebt * 100000),
         otherdebt = (otherdebt * 100000))
# Now let us create our total_debt column
cust_df = cust_df %>%
  mutate(total_debt = (creditdebt + otherdebt))

# Let us look at distribution of total_debt
hist(cust_df$total_debt,
     xlab = "Total Debt",
     ylab = "Frequency",
     main = "Distribution of Total Value")

# Distribution is skewed heavily to the right. Let us try log transformation
head(table(cust_df$total_debt))

# We see that one customer has 0 debt. We cannot log transform that value so let us remove it
cust_df = cust_df[cust_df$total_debt != 0, ]

# Now let us look at log transformation
hist(log(cust_df$total_debt),
     xlab = "log(Total Debt)",
     ylab = "Frequency",
     main = "Distribution of log(Total Debt")

# Much more normal distribution. Let us log transform the vector in our data set
cust_df = cust_df %>%
  mutate(log_tot_debt = log(total_debt))

# Now let us look at outliers in log_tot_debt
boxplot(cust_df$log_tot_debt,
        xlab = "Log Total Debt",
        ylab = "Frequency",
        main = "Distribution of Log Total Debt")
# There are a lot of outliers. Let us remove the outliers.
q = quantile(cust_df$log_tot_debt, c(0.25, 0.75))
iqr = q[2] - q[1]

# Set the range for outliers
low_q = q[1] - 1.5 * iqr
upper_q = q[2] + 1.5 * iqr

# Remove outliers from the dataframe
cust_df = cust_df[cust_df$log_tot_debt >= low_q 
                  & cust_df$log_tot_debt <= upper_q, ]
# Look at boxplot again
boxplot(cust_df$log_tot_debt,
        xlab = "Log Total Debt",
        ylab = "Frequency",
        main = "Distribution of Log Total Debt")
# This removed our outliers.
```

## Car Brand
```{r carbrand}
# Let us look at carbrand values
class(cust_df$carbrand)
# character
unique(cust_df$carbrand)
# We see that there is a -1 value that shows up. Let us remove the -1 and have it say "None" 
cust_df = cust_df %>%
  mutate(carbrand = ifelse(carbrand == "-1", "None", carbrand))
unique(cust_df$carbrand)
# Check to see total counts of each observation
table(cust_df$carbrand)
```
## Car Value
```{r car value}
# Let us look at carvalue variable. Let us look at class of variable.
class(cust_df$carvalue)
# Character
# We see that for those that do not own a vehicle, the value for carvalue is $(1,000.00). Let us convert those to 0 strings.
cust_df = cust_df %>%
  mutate(carvalue = ifelse(carbrand == "None", "0", carvalue))
# Now let us remove non-numeric characters and convert carvalue to a numeric vector
cust_df = cust_df %>%
  mutate(carvalue = as.numeric(str_replace_all(carvalue, "[^0-9.]", "")))
class(cust_df$carvalue)
# Numeric
min(cust_df$carvalue)
# 0

# Let us look at distribution of car value
hist(cust_df$carvalue,
     xlab = "Car Value",
     ylab = "Frequency",
     main = "Distribution of Car Value")
# Distribution is right skewed. 
# Let us remove observations where carvalue equals 0
# Remove observations where carvalue equals zero
cust_df = cust_df[cust_df$carvalue != 0, ]

# Now let us try log transformation
hist(log(cust_df$carvalue),
     xlab = "Car Value",
     ylab = "Frequency",
     main = "Distribution of log(Car Value)")
# This makes the distribution much more normal. Let us create a new variable that takes log of carvalue
cust_df = cust_df %>%
  mutate(log_car_val = log(carvalue))

# Let us look at boxplot of log_car_val
boxplot(cust_df$log_car_val,
        xlab = "Log Car Value",
        ylab = "Frequency",
        main = "Distribution of Log Car Value")

# We only see a few outliers. Let us remove them
q = quantile(cust_df$log_car_val, c(0.25, 0.75))
iqr = q[2] - q[1]

# Set the range for outliers
low_q = q[1] - 1.5 * iqr
upper_q = q[2] + 1.5 * iqr

# Remove outliers from the dataframe
cust_df = cust_df[cust_df$log_car_val >= low_q 
                  & cust_df$log_car_val <= upper_q, ]

# Check for outliers again
boxplot(cust_df$log_car_val,
        xlab = "Log Car Value",
        ylab = "Frequency",
        main = "Distribution of Log Car Value")
# Outliers are removed
```

## Create Subset of Data
```{r new data frame}
sub_columns = c("region", "numberpets", "householdsize", "homeowner", "jobcategory", "carbrand", "log_car_val", "log_hh_income", "log_tot_debt", "log_tot_value")
sub_cust_df = cust_df[,sub_columns]

dim(sub_cust_df)
# 4347 observations
# 10 variables

# Export subset to Excel file
write.xlsx(sub_cust_df, "customer_data_subset.xlsx", rowNames = TRUE)
```

# Summary of Data

# Tableau Visualizations
